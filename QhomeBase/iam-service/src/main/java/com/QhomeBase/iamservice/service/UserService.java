package com.QhomeBase.iamservice.service;

import com.QhomeBase.iamservice.dto.UserAccountDto;
import com.QhomeBase.iamservice.model.StaffProfile;
import com.QhomeBase.iamservice.model.User;
import com.QhomeBase.iamservice.model.UserRole;
import com.QhomeBase.iamservice.repository.StaffProfileRepository;
import com.QhomeBase.iamservice.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.mail.MailException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.regex.Pattern;

@Service
@RequiredArgsConstructor
@Slf4j
public class UserService {

    private static final Pattern STRONG_PASSWORD_PATTERN = Pattern.compile(
            "^(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$");

    public final UserRepository userRepository;
    private final StaffProfileRepository staffProfileRepository;
    private final PasswordEncoder passwordEncoder;
    private final EmailService emailService;

    @Transactional
    public User createUserForResident(String username, String email, String password, UUID residentId,
            String buildingName) {
        // Validate and trim username
        if (username == null || username.isBlank()) {
            throw new IllegalArgumentException("Username cannot be empty");
        }
        String trimmedUsername = username.trim();
        validateUsername(trimmedUsername);
        username = trimmedUsername;

        // Check if username already exists
        if (userRepository.findByUsername(username).isPresent()) {
            throw new IllegalArgumentException("Username already exists: " + username);
        }

        // Check if email already exists
        if (userRepository.findByEmail(email).isPresent()) {
            throw new IllegalArgumentException("Email already exists: " + email);
        }

        // Hash password
        String passwordHash = passwordEncoder.encode(password);

        // Create user
        User user = User.builder()
                .username(username)
                .email(email)
                .passwordHash(passwordHash)
                .active(true)
                .build();

        // Add RESIDENT role
        user.addRole(UserRole.RESIDENT);

        User savedUser = userRepository.save(user);
        log.info("Created user account for resident {}: userId={}, username={}",
                residentId, savedUser.getId(), savedUser.getUsername());

        if (StringUtils.hasText(email)) {
            try {
                emailService.sendResidentAccountCredentials(email, username, password, buildingName);
            } catch (MailException mailException) {
                log.error("Failed to send resident credentials email to {} for user {}", email, savedUser.getId(),
                        mailException);
            }
        } else {
            log.warn("Resident {} has no email; credentials email was not sent", residentId);
        }

        return savedUser;
    }

    @Transactional
    public User createUserWithAutoGeneratedPassword(String username, String email, UUID residentId,
            String buildingName) {
        // Generate random password (8 characters)
        // Username validation will be done in createUserForResident
        String randomPassword = generateRandomPassword(8);
        return createUserForResident(username, email, randomPassword, residentId, buildingName);
    }

    private String generateRandomPassword(int length) {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
        StringBuilder password = new StringBuilder();
        for (int i = 0; i < length; i++) {
            int index = (int) (Math.random() * chars.length());
            password.append(chars.charAt(index));
        }
        return password.toString();
    }

    public Optional<User> findByEmail(String email) {
        return userRepository.findByEmail(email);
    }

    public Optional<User> findByUsername(String username) {
        return userRepository.findByUsername(username);
    }

    public User save(User user) {
        return userRepository.save(user);
    }

    public boolean matchesPassword(String rawPassword, String hashedPassword) {
        return passwordEncoder.matches(rawPassword, hashedPassword);
    }

    public String encodePassword(String rawPassword) {
        return passwordEncoder.encode(rawPassword);

    }

    @Transactional
    public void updatePassword(UUID userId, String newPassword) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found: " + userId));

        if (!isStrongPassword(newPassword)) {
            throw new IllegalArgumentException(
                    "Password must be at least 8 characters and contain at least one special character");
        }

        if (passwordEncoder.matches(newPassword, user.getPasswordHash())) {
            throw new IllegalArgumentException("New password must be different from old password");
        }

        String encodedPassword = passwordEncoder.encode(newPassword);
        user.setPasswordHash(encodedPassword);
        userRepository.save(user);
        log.info("Updated password for user {}", userId);
    }

    private boolean isStrongPassword(String password) {
        return STRONG_PASSWORD_PATTERN.matcher(password).matches();
    }

    @Transactional(readOnly = true)
    public Optional<User> findUserWithRolesById(UUID userId) {
        return userRepository.findById(userId).map(this::initializeRoles);
    }

    @Transactional(readOnly = true)
    public Optional<User> findUserWithRolesByUsername(String username) {
        return userRepository.findByUsername(username).map(this::initializeRoles);
    }

    @Transactional(readOnly = true)
    public Optional<User> findUserWithRolesByEmail(String email) {
        return userRepository.findByEmail(email).map(this::initializeRoles);
    }

    @Transactional(readOnly = true)
    public List<User> findAvailableStaffWithRoles() {
        log.warn("üî• findAvailableStaffWithRoles - CACHE MISS - QUERY DATABASE");
        List<User> users = userRepository.findAvailableStaff();
        users.forEach(this::initializeRoles);
        return users;
    }

    public List<User> findStaffWithRoles() {
        List<User> users = userRepository.findStaffUsers();
        users.forEach(this::initializeRoles);
        return users;
    }

    public List<UserAccountDto> findStaffAccountDtos() {
        return findStaffWithRoles()
                .stream()
                .map(this::mapToUserAccountDto)
                .toList();
    }

    public UserAccountDto mapToUserAccountDto(User user) {
        StaffProfile profile = staffProfileRepository.findByUserId(user.getId()).orElse(null);
        return new UserAccountDto(
                user.getId(),
                user.getUsername(),
                user.getEmail(),
                user.getRoles() != null
                        ? user.getRoles().stream()
                                .map(UserRole::getRoleName)
                                .toList()
                        : List.of(),
                user.isActive(),
                profile != null ? profile.getFullName() : null,
                profile != null ? profile.getPhone() : null,
                profile != null ? profile.getNationalId() : null,
                profile != null ? profile.getAddress() : null);
    }

    @Transactional(readOnly = true)
    public Optional<User> findStaffWithRolesById(UUID userId) {
        return userRepository.findById(userId)
                .map(this::initializeRoles)
                .filter(user -> user.getRoles().stream().anyMatch(this::isStaffRole));
    }

    @Transactional(readOnly = true)
    public List<User> findResidentAccounts() {
        List<User> users = userRepository.findByRoleIncludingInactive(UserRole.RESIDENT.name());
        users.forEach(this::initializeRoles);
        return users;
    }

    @Transactional(readOnly = true)
    public List<User> findResidentAccountsByUserIds(List<UUID> userIds) {
        if (userIds == null || userIds.isEmpty()) {
            return List.of();
        }
        List<User> users = userRepository.findAllById(userIds);
        users.forEach(this::initializeRoles);
        return users;
    }

    @Transactional
    public User createStaffAccount(String username, String email, List<UserRole> roles, boolean active,
            String fullName, String phone, String nationalId, String address) {
        if (!StringUtils.hasText(username)) {
            throw new IllegalArgumentException("Username cannot be empty");
        }
        String trimmedUsername = username.trim();
        validateUsername(trimmedUsername);

        if (!StringUtils.hasText(email)) {
            throw new IllegalArgumentException("Email cannot be empty");
        }
        String trimmedEmail = email.trim();
        validateEmail(trimmedEmail);

        if (roles == null || roles.isEmpty()) {
            throw new IllegalArgumentException("Staff account requires at least one role");
        }
        if (roles.stream().anyMatch(role -> role == UserRole.ADMIN)) {
            throw new IllegalArgumentException("Cannot create admin accounts through this endpoint");
        }
        if (roles.stream().anyMatch(role -> role == UserRole.RESIDENT || role == UserRole.UNIT_OWNER)) {
            throw new IllegalArgumentException("Staff account cannot include resident or unit owner roles");
        }
        if (userRepository.findByUsername(trimmedUsername).isPresent()) {
            throw new IllegalArgumentException("Username already exists: " + trimmedUsername);
        }
        if (userRepository.findByEmail(trimmedEmail).isPresent()) {
            throw new IllegalArgumentException("Email already exists: " + trimmedEmail);
        }
        String rawPassword = generateRandomPassword(12);
        String encodedPassword = passwordEncoder.encode(rawPassword);
        User user = User.builder()
                .username(trimmedUsername)
                .email(trimmedEmail)
                .passwordHash(encodedPassword)
                .active(active)
                .build();
        roles.forEach(user::addRole);
        roles.forEach(user::addRole);
        User saved = userRepository.save(user);
        log.info("Created staff user account {} with roles {}", saved.getId(), roles);

        // Create StaffProfile
        StaffProfile profile = StaffProfile.builder()
                .user(saved)
                .fullName(fullName)
                .phone(phone)
                .nationalId(nationalId)
                .address(address)
                .build();
        staffProfileRepository.save(profile);

        try {
            emailService.sendStaffAccountCredentials(trimmedEmail, trimmedUsername, rawPassword);
        } catch (MailException mailException) {
            log.error("Failed to send credentials email to {} for staff account {}", trimmedEmail, saved.getId(),
                    mailException);
        }
        return initializeRoles(saved);
    }

    @Transactional
    public User updateStaffAccount(UUID userId,
            String username,
            String email,
            Boolean active,
            String newPassword,
            List<UserRole> roles,
            String fullName,
            String phone,
            String nationalId,
            String address) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found: " + userId));
        initializeRoles(user);
        if (user.getRoles().stream().anyMatch(role -> role == UserRole.RESIDENT || role == UserRole.UNIT_OWNER)) {
            throw new IllegalArgumentException("Cannot update resident or unit owner using staff endpoint");
        }

        if (username != null && !username.isBlank() && !username.equalsIgnoreCase(user.getUsername())) {
            String trimmedUsername = username.trim();
            validateUsername(trimmedUsername);
            userRepository.findByUsername(trimmedUsername).ifPresent(existing -> {
                if (!existing.getId().equals(userId)) {
                    throw new IllegalArgumentException("Username already exists: " + trimmedUsername);
                }
            });
            user.setUsername(trimmedUsername);
        }

        if (email != null && !email.isBlank() && !email.equalsIgnoreCase(user.getEmail())) {
            String trimmedEmail = email.trim();
            validateEmail(trimmedEmail);
            userRepository.findByEmail(trimmedEmail).ifPresent(existing -> {
                if (!existing.getId().equals(userId)) {
                    throw new IllegalArgumentException("Email already exists: " + trimmedEmail);
                }
            });
            user.setEmail(trimmedEmail);
        }

        if (active != null) {
            user.setActive(active);
        }

        if (newPassword != null && !newPassword.isBlank()) {
            String encodedPassword = passwordEncoder.encode(newPassword);
            user.setPasswordHash(encodedPassword);
        }

        if (roles != null) {
            if (roles.isEmpty()) {
                throw new IllegalArgumentException("Staff account requires at least one role");
            }
            if (roles.stream().anyMatch(role -> role == UserRole.ADMIN)) {
                throw new IllegalArgumentException("Cannot assign admin role through this endpoint");
            }
            if (roles.stream().anyMatch(role -> role == UserRole.RESIDENT || role == UserRole.UNIT_OWNER)) {
                throw new IllegalArgumentException("Staff account cannot include resident or unit owner roles");
            }
            user.setRoles(new java.util.ArrayList<>(roles));
        }

        User saved = userRepository.save(user);

        // Update StaffProfile
        Optional<StaffProfile> profileOpt = staffProfileRepository.findByUserId(userId);
        StaffProfile profile;
        if (profileOpt.isPresent()) {
            profile = profileOpt.get();
            if (fullName != null)
                profile.setFullName(fullName);
            if (phone != null)
                profile.setPhone(phone);
            if (nationalId != null)
                profile.setNationalId(nationalId);
            if (address != null)
                profile.setAddress(address);
        } else {
            // Create if missing (should not happen for valid staff but good fallback)
            profile = StaffProfile.builder()
                    .user(saved)
                    .fullName(fullName != null ? fullName : "")
                    .phone(phone)
                    .nationalId(nationalId)
                    .address(address)
                    .build();
        }
        staffProfileRepository.save(profile);

        log.info("Updated staff user account {}", userId);
        return initializeRoles(saved);
    }

    @Transactional
    public void deleteStaffAccount(UUID userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found: " + userId));
        initializeRoles(user);
        if (user.getRoles().stream().anyMatch(role -> role == UserRole.RESIDENT || role == UserRole.UNIT_OWNER)) {
            throw new IllegalArgumentException("Cannot delete resident or unit owner using staff endpoint");
        }
        userRepository.delete(user);
        log.info("Deleted staff user account {}", userId);
    }

    private User initializeRoles(User user) {
        user.getRoles().size();
        return user;
    }

    private boolean isStaffRole(UserRole role) {
        return role == UserRole.ADMIN
                || role == UserRole.ACCOUNTANT
                || role == UserRole.TECHNICIAN
                || role == UserRole.SUPPORTER;
    }

    private void validateUsername(String username) {
        if (username.contains(" ")) {
            throw new IllegalArgumentException("Username kh√¥ng ƒë∆∞·ª£c ch·ª©a kho·∫£ng tr·∫Øng");
        }

        if (!username.matches("^[a-zA-Z].*")) {
            throw new IllegalArgumentException("Username ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng ch·ªØ c√°i (a-z, A-Z)");
        }

        if (username.matches(".*[._]$")) {
            throw new IllegalArgumentException("Username kh√¥ng ƒë∆∞·ª£c k·∫øt th√∫c b·∫±ng k√Ω t·ª± ƒë·∫∑c bi·ªát (., _)");
        }

        if (!username.matches("^[a-zA-Z0-9._]+$")) {
            throw new IllegalArgumentException(
                    "Username ch·ªâ ƒë∆∞·ª£c ch·ª©a ch·ªØ c√°i (a-z, A-Z), s·ªë (0-9), d·∫•u g·∫°ch d∆∞·ªõi (_) v√† d·∫•u ch·∫•m (.)");
        }

        if (username.contains("..")) {
            throw new IllegalArgumentException("Username kh√¥ng ƒë∆∞·ª£c ch·ª©a nhi·ªÅu d·∫•u ch·∫•m li√™n ti·∫øp");
        }

        String forbiddenChars = "&=+<>?/\\|{}[]()*^$#@!%~`";
        for (char c : forbiddenChars.toCharArray()) {
            if (username.indexOf(c) >= 0) {
                throw new IllegalArgumentException("Username kh√¥ng ƒë∆∞·ª£c ch·ª©a k√Ω t·ª± b·ªã c·∫•m: " + c);
            }
        }
    }

    private void validateEmail(String email) {
        if (email == null || email.isEmpty()) {
            throw new IllegalArgumentException("Email cannot be empty");
        }

        long atCount = email.chars().filter(ch -> ch == '@').count();
        if (atCount != 1) {
            throw new IllegalArgumentException("Email ph·∫£i c√≥ ƒëu√¥i .com. V√≠ d·ª•: user@example.com");
        }

        String emailPattern = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com$";
        if (!email.matches(emailPattern)) {
            throw new IllegalArgumentException("Email ph·∫£i c√≥ ƒëu√¥i .com. V√≠ d·ª•: user@example.com");
        }

        if (email.length() > 255) {
            throw new IllegalArgumentException("Email kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° 255 k√Ω t·ª±");
        }
    }

    public String getPhone(UUID userId) {
        return staffProfileRepository.findByUserId(userId)
                .map(StaffProfile::getPhone)
                .orElse(null);
    }
}
